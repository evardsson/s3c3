<?php
/**
 * Token class.
 *
 * The Token class generates tokens (of a length and strength determined by the
 * local configuration) and turns those into token requests or responses to pass to
 * the listener and client respectively. It can also parse those requests and
 * responses for the listener and client to properly encapsulate all the token
 * logic.
 *
 * @author Sjan Evardsson <sjan@evardsson.com>
 * @link http://www.evardsson.com/
 * @copyright Sjan Evardsson 2013
 * @version 1.0
 * @package s3c3
 * @subpackage core
 */
namespace s3c3\core;

use \s3c3\conf\Config;
use \s3c3\except\InvalidArgumentException;

/**
 * class Token
 *
 * @since version 1.0
 */
class Token
{
    
    const TBEGIN    = 'begin';
    const TCONTINUE = 'continue';
    const TEND      = 'end';
    
    /**
     * string token
     * @var token
     * @access protected
     */
    protected $token;

    /**
     * string token client name
     * @var client
     * @access protected
     */
    protected $client;

    /**
     * string expiration timestamp YYYY-MM-DD HH.MM.SS
     * @var expires
     * @access protected
     */
    protected $expires;

    /**
     * string token type
     * @var type
     * @access protected
     */
    protected $type;

    /**
     * Constructor
     * Create a new Token
     *
     * @param string client the token consumer's S3C3 scheme name
     * @param string token the token string sent by the listener to the client
     */
    public function __construct($client, $token = null)
    {
        $this->client = $client;
        $this->token = $token;
    }

    /**
     * Create a token request
     *
     * @param string type (one of Token::TBEGIN, Token::TCONTINUE or Token::TEND)
     * @return string Token request ready for encryption
     */
    public function createRequest($type)
    {
        if (empty($this->token) && $type != self::TBEGIN) {
            throw new InvalidArgumentException(
                "Cannot generate a request of type $type with no current token.");
        }
        if ($type == self::TBEGIN) $this->token = microtime();
        return "$type:{$this->token}:{$this->client}";
    }

    /**
     * Get the client
     *
     * @return string
     */
    public function getClient()
    {
        return $this->client;
    }

    /**
     * Get the token string
     *
     * @return string
     */
    public function getTokenString()
    {
        return $this->token;
    }

    /**
     * Get the expiration
     *
     * @return string
     */
    public function getExpires()
    {
        return $this->expires;
    }

    /**
     * Get the type
     *
     * @return string
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * Parse a token request
     *
     * @param string tokenRequest as is generated by createRequest
     * @return array ('type' => type, 'token' => token, 'client' => client)
     */
    public static function parseRequest($tokenRequest, $asobject = false)
    {
        if (!is_string($tokenRequest) || strpos($tokenRequest, ':') === false) {
            throw new InvalidArgumentException(
                'Invalid argument to Token::parseRequest: '.$tokenRequest);
        }
        list($type, $token, $client) = explode(':', $tokenRequest);
        if (!$asobject) {
            return array('type' => $type, 'token' => $token, 'client' => $client);
        } else {
            $t = new self($client, $token);
            $t->type = $type;
            return $t;
        }
    }
    
    /**
     * Create a token response
     *
     * @param string type (one of Token::TBEGIN, Token::TCONTINUE or Token::TEND)
     */
    public function createResponse($type)
    {
        if ($type == self::TEND) {
            $this->token = microtime();
            $this->expires = date('Y-m-d H.i.s');
        } else {
            $this->token = $this->generate();
            $this->expires = date('Y-m-d H.i.s', time() + Config::getInstance()->read('token.expire'));
        }
        return "{$this->expires}:{$this->token}:{$this->client}";
    }

    /**
     * Parse a token response and return a new Token object based on that response
     *
     * @param string tokenResponse as is generated by createResponse
     * @return object Token
     */
    public static function parseResponse($tokenResponse, $cxx)
    {
        list($expires, $token, $client) = explode(':', $tokenResponse);
        return new self($client, $token);
    }
    
    /**
     * Generate a token
     *
     * @param int length
     * @return string token
     */
    private function generate()
    {
        $length = Config::getInstance()->read('token.length');
        $str = strtolower(Config::getInstance()->read('token.strength'));
        if ($str == 'weak') return $this->generateWeak($length);
        switch ($str) {
            case 'medium':
                $chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
                break;
            case 'strong':
                $chars = '#+-./0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~';
                break;
            case 'maximum':
            default:
                $chars = '';
                for ($i = 32; $i < 127; $i++) $chars .= chr($i);
                $chars = str_replace(':','',$chars);
                break;
        }
        $cx = strlen($chars) -1;
        $retval = array();
        for ($i = 0; $i < $length; $i++) {
            $retval[] = $chars{mt_rand(0, $cx)};
        }
        while ($retval[0] == ' ') {
            $retval[0] = $chars{mt_rand(0, $cx)};
        }
        while ($retval[$length-1] == ' ') {
            $retval[$length-1] = $chars{mt_rand(0, $cx)};
        }
        return implode('', $retval);
    }
    
    /**
     * Generate a weak token
     *
     * @param int length
     * @return string token
     */
    private function generateWeak($length)
    {
        $retval = '';
        while (strlen($retval) < $length) {
            $retval .= hash('sha256', uniqid().microtime());
        }
        return substr($retval, 0, $length);
    } 
}
